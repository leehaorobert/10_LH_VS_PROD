# LH_VS_价值策略

'''
================================================================================
导入Python库文件
================================================================================
'''
import pandas as pd
import numpy as np
import datetime as dt
from six import StringIO

'''
================================================================================
总体回测前
================================================================================
'''
#总体回测前要做的事情,g变量设定后无法在交易中通过更新代码的方式进行修改
def initialize(context):
    set_variables()                          # 设置中间变量
    set_backtest()                           # 设置回测条件
    set_benchmark('000300.XSHG')             # 设置回测基准
    #set_benchmark('399006.XSHE')
    set_trade_freq()                         # 设置交易频率，按天、周、月



#设置中间变量，仅定义需要在回测间保存的变量
def set_variables():
    # 计算待持有的股票列表
    g.intra_industry_count = 2               # 定义组合中同一个行业的股票个数
    g.stock_to_hold_last = []                # 初始化变量
    g.stock_to_buy_limit = 10                # 定义买入股票的排名阈值
    #g.stock_to_sell_limit = 15               # 定义卖出股票的排名阈值
    # 计算持仓比例
    g.risk_lag = 180                         # 定义计算风险的分析期间
    g.confidence_level = 2.58                # 定义置信率，即：正态分布下的发生概率，1.96, 95%; 2.06, 96%; 2.18, 97%; 2.34, 98%; 2.58, 99%; 5, 99.9999%
    g.portfolio_risk_lag = 180
    g.portfolio_confidence_level = 1.96      # 1.96, 95%
    g.portfolio_risk_rate = 0.03             # 定义能够成熟的最大损失

#设置回测条件
def set_backtest():
    set_option('use_real_price',True)        # 用真实价格交易
    log.set_level('order','error')           # 设置报错等级


def set_trade_freq():
    # 指定每月第一个交易日, 在开盘第一分钟执行
    #run_monthly(monthly, 1, 'open')

    # 指定每周倒数第一个交易日, 在开盘前执行, 此函数中不能下单
    #run_weekly(weekly, -1, 'before_open')
    run_weekly(lh_main,-1,'open')

    # 指定每天收盘后执行, 此函数中不能下单
    #run_daily(daily, 'after_close')
    #run_daily(lh_main,'open')

    # 指定在每天的10:00运行, 必须选择分钟回测, 否则不会执行
    #run_daily(daily, '10:00')

    # 指定在每天的14:00运行, 必须选择分钟回测, 否则不会执行
    #run_daily(daily, '14:00')

'''
================================================================================
每天开盘前
================================================================================
'''
#每天开盘前要做的事情
def before_trading_start(context):

    # 设置手续费
    set_slip_fee(context)

# 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0))
    # 根据不同的时间段设置手续费
    dt=context.current_dt
    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))


'''
================================================================================
交易时
================================================================================
'''
def lh_main(context):

    # 引用 lib
    g.prepare = lh_prepare_lib()
    g.algorithm = lh_algo_lib()
    g.trade = lh_trade_lib()
    g.operation = lh_operation_lib()


    # 取得股票池列表
    g.stock_pool_list = g.prepare.get_stock_pool_list(context)

    # 计算待持有的股票列表
    g.stock_to_hold_list = g.algorithm.get_hold_stock_list(context,g.stock_pool_list)

    # 计算持有股票的仓位
    g.stock_to_trade_df = g.trade.get_stock_to_trade_df(context,g.stock_to_hold_list)

    # 执行卖出和买入操作
    g.operation.trade_execution(context,g.stock_to_trade_df)



################################################################################
################################################################################
class lh_prepare_lib():

    def __init__(self, _period = '1d'):
        pass

    def set_stock_pool_scope(self,context):
        initial_stocks = list(get_all_securities(['stock'], context.current_dt.date()).index)
        return initial_stocks

    def delete_pause_stock(self,context,initial_stocks):
        # 判断初始股票池的股票是否停牌，返回list
        paused_info = []
        current_data = get_current_data()
        for i in initial_stocks:
            paused_info.append(current_data[i].paused)
        df_paused_info = pd.DataFrame({'paused_info':paused_info},index = initial_stocks)
        unsuspened_stocks =list(df_paused_info.index[df_paused_info.paused_info == False])
        return unsuspened_stocks

    def delete_new_stock(self,context,stock_list,deltaday):
        deltaDate = context.current_dt.date() - dt.timedelta(deltaday)
        stock_list_new = []
        for stock in stock_list:
            if get_security_info(stock).start_date < deltaDate:
                stock_list_new.append(stock)
        return stock_list_new

    # submain
    def get_stock_pool_list(self,context):
        # 初始化
        initial_stocks = self.set_stock_pool_scope(context)
        # 去除停牌的股票
        stock_pool_list = self.delete_pause_stock(context,initial_stocks)
        # 去除刚上市的股票，因为新股无法根据历史走势计算风险系数
        stock_pool_list = self.delete_new_stock(context,stock_pool_list,300)
        return stock_pool_list

################################################################################
class lh_algo_lib():

    def __init__(self, _period = '1d'):
        pass

    def get_PEG_df(self,context,stock_pool_list):
        # 查询股票池里股票的市盈率，收益增长率
        q_PE_G = query(valuation.code, \
                       valuation.pe_ratio, \
                       indicator.inc_revenue_year_on_year, \
                       indicator.inc_net_profit_year_on_year,\
                       valuation.market_cap, \
                         ).filter(valuation.code.in_(stock_pool_list))
        # 默认date = context.current_dt的前一天,使用默认值，避免未来函数，不建议修改
        df_data = get_fundamentals(q_PE_G)
        df_data = df_data.dropna()
        # 重新给columns命名
        df_data.columns = ['code','pe','inc_rev_yoy','inc_npft_yoy','mkt_cap']
        # 得到一个Series：存放股票的市盈率TTM，即PE值
        stock_PE = df_data['pe'].values
        # 得到一个Series：存放股票的收益增长率，即G值
        stock_G = df_data['inc_npft_yoy'].values
        # 得到一个Series：存放股票的PEG值
        stock_PEG = stock_PE/stock_G
        # 将PEG插入到df
        df_data.insert(5,'peg',stock_PEG)
        # 将df的index更新为股票代码，并删掉原股票代码列
        df_data.index = df_data['code'].values
        df_data = df_data.drop('code',axis=1)
        return df_data

    def filter_PEG_df(self,context,df_PEG):
        # 将股票按PEG升序排列，返回daraframe类型
        df_sort_PEG = df_PEG.sort(columns=['peg'], ascending=[1])
        # 筛选出符合条件的股票
        df_sort_PEG = df_sort_PEG[(df_sort_PEG.inc_rev_yoy>0)&(df_sort_PEG.inc_rev_yoy<150)&\
                                  (df_sort_PEG.inc_npft_yoy>0)&(df_sort_PEG.inc_npft_yoy<150)&\
                                  (df_sort_PEG.pe>0)&\
                                  (df_sort_PEG.mkt_cap<1000)]
        return df_sort_PEG

    def diversify_by_industry(self,context,df_sort_PEG):
        # 初始化
        industry_list = []
        # 读取数据文件
        body = read_file('data/stock_industry_info.csv')
        # 读取数据的第一列为index
        pd_data = pd.read_csv(StringIO(body), index_col=0)
        # 复制index
        peg_index = df_sort_PEG.index
        # 开始循环处理
        for stock_code in peg_index:
            # 防止行业信息不全
            if stock_code in pd_data.index:
                # 获得该股票的行业代码
                industry_code = pd_data['industry_code'][stock_code]
                # 进行判断
                if industry_list.count(industry_code) <= g.intra_industry_count:
                    # 将该行业code加入到列表
                    industry_list.append(industry_code)
                if industry_list.count(industry_code) > g.intra_industry_count:
                    # 删除该行
                    df_sort_PEG = df_sort_PEG.drop(stock_code)
        #df_sort_PEG.insert(5,'rank',np.arange(0,df_sort_PEG.shape[0]))
        return df_sort_PEG

    def extend_hold_period(self,context,df_PEG_filter):
        # 初始化
        stock_to_hold_list = []
        hold_list_prep = df_PEG_filter.index.values
        hold_list_last = g.stock_to_hold_last
        # 注意：策略在初始化时，会一次性买入股票
        # 将满足购买条件的股票加入到清单
        for i in range(0,g.stock_to_buy_limit):
            stock_to_hold_list.append(hold_list_prep[i])
        # 将未跌出卖出条件的股票加入到购买清单
        for i in range(g.stock_to_buy_limit,g.stock_to_sell_limit):
            if hold_list_prep[i] in hold_list_last:
                stock_to_hold_list.append(hold_list_prep[i])
        # 保存变量
        g.stock_to_hold_last = stock_to_hold_list
        return stock_to_hold_list

    def get_stock_list_by_count(self,context,df_PEG_filter):
        stock_to_hold_list = df_PEG_filter.index.values[:g.stock_to_buy_limit]
        return stock_to_hold_list

    # submain
    def get_hold_stock_list(self,context,stock_pool_list):
        # 取得PEG df：index为股票代码，data为相应的PEG值
        df_PEG = self.get_PEG_df(context, stock_pool_list)
        # 对PEG df进行筛选
        df_PEG_filter = self.filter_PEG_df(context,df_PEG)
        # 限制股票列表中每个行业所占股票的数量
        df_PEG_filter = self.diversify_by_industry(context,df_PEG_filter)
        # 取得待持有的股票列表
        #stock_to_hold_list = self.extend_hold_period(context,df_PEG_filter)
        stock_to_hold_list = self.get_stock_list_by_count(context,df_PEG_filter)

        return stock_to_hold_list

################################################################################
class lh_trade_lib():

    def __init__(self, _period = '1d'):
        pass

    def get_stock_pause_info(self,context,stock_code):
        # 取得所有数据信息
        current_data = get_current_data()
        stock_pause_status = current_data[stock_code].paused

        return stock_pause_status

    def get_stock_zhangting_info(self,context,stock_code):
        # 取得所有数据信息
        current_data = get_current_data()
        # 判断涨停信息
        today_open = current_data[stock_code].day_open
        yest_close = history(count=1, unit='1d', field='close', security_list=stock_code).values
        zhangting_status = (today_open/yest_close > 1.09)
        return zhangting_status

    # ES风险计算逻辑
    def cal_stock_risk_ES(self,context,stock_code,risk_lag,confidence_level):
        # 取得历史收盘数据
        hStocks = history(risk_lag, '1d', 'close', stock_code)
        # 计算日收益率／日变动率
        #dailyReturns = hStocks.resample('D',how='last').pct_change().fillna(value=0, method=None, axis=0).values
        dailyReturns = hStocks.pct_change().fillna(value=0, method=None, axis=0).values
        # 按照升序排序
        dailyReturns_sort =  sorted(dailyReturns)

        # 根据置信水平，计算Alpha。表示基于正态分布函数下的事件发生概率
        if confidence_level   == 1.96:
            alpha = (1 - 0.95)
        elif confidence_level == 2.06:
            alpha = (1 - 0.96)
        elif confidence_level == 2.18:
            alpha = (1 - 0.97)
        elif confidence_level == 2.34:
            alpha = (1 - 0.98)
        elif confidence_level == 2.58:
            alpha = (1 - 0.99)
        elif confidence_level == 5:
            alpha = (1 - 0.99999)
        else:
            alpha = (1 - 0.95)
        # 根据risk_lag(采样期间)和alpha，计算ES的期间
        ES_sample = risk_lag * alpha
        # 初始化
        count = 0
        sum_value = 0
        # 计算ES的和
        for i in range(len(dailyReturns_sort)):
            if i < ES_sample:
                sum_value = sum_value+dailyReturns_sort[i][0]
                count = count+1
        # 计算ES
        if count == 0:
            ES = 0
        else:
            ES = -(sum_value / ES_sample)
        if isnan(ES):
            ES = 0
        return ES

    # 新的配仓分配逻辑
    def cal_stock_alloc_ratio(self,context,stock_to_hold_list):
        # 初始化
        stock_alloc_ratio_df = pd.DataFrame(index=stock_to_hold_list,columns=['risk_ES','position','position_ratio'])
        # 计算风险系数ES的值
        for stock_code_tmp in stock_to_hold_list:
            stock_alloc_ratio_df['risk_ES'][stock_code_tmp] = self.cal_stock_risk_ES(context,stock_code_tmp,g.risk_lag,g.confidence_level)
            stock_alloc_ratio_df['position'][stock_code_tmp] = 1.0 / stock_alloc_ratio_df['risk_ES'][stock_code_tmp]
        # 根据ES值计算持仓比例
        total_position = sum(stock_alloc_ratio_df['position'].values)
        for stock_code_tmp in stock_to_hold_list:
            ratio_tmp = stock_alloc_ratio_df['position'][stock_code_tmp]/total_position
            if isnan(ratio_tmp):
                ratio_tmp = 0
            stock_alloc_ratio_df['position_ratio'][stock_code_tmp] = round(ratio_tmp, 4)

        return stock_alloc_ratio_df

    # 根据各支股票的持仓比例，计算调仓信息
    def get_stock_trade_info(self,context,stock_alloc_ratio_df,portfolio_alloc_ratio):
        # 初始化
        stock_to_trade_df = pd.DataFrame(columns=['stock_code','buyorsell','original_value','target_value'])
        # 取得当前的持仓信息
        curr_hold_stock_list = context.portfolio.positions.keys()
        # 取得可分配的总金额
        total_capital = context.portfolio.portfolio_value * portfolio_alloc_ratio
        # 取得待卖出的股票中，已停牌和已涨停的股票信息
        unavailable_capital = 0
        # 如果该股票在当前持仓中，但不在未来持仓清单中
        for stock_code in curr_hold_stock_list:
            if stock_code not in stock_alloc_ratio_df.index:
                if self.get_stock_pause_info(context,stock_code)==True:
                    unavailable_capital = unavailable_capital+context.portfolio.positions[stock_code].value
                elif self.get_stock_zhangting_info(context,stock_code)==True:
                    unavailable_capital = unavailable_capital+context.portfolio.positions[stock_code].value
                else:
                    current_value_tmp = context.portfolio.positions[stock_code].value
                    stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'sell',current_value_tmp,0.0]],columns=['stock_code','buyorsell','original_value','target_value'])
                    stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
        # 计算可分配的金额
        available_capital = total_capital-unavailable_capital
        # Loop
        for stock_code in stock_alloc_ratio_df.index:
            current_value_tmp = context.portfolio.positions[stock_code].value
            target_value_tmp = stock_alloc_ratio_df['position_ratio'][stock_code] * available_capital
            if current_value_tmp > target_value_tmp:
                stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'sell',current_value_tmp,target_value_tmp]],columns=['stock_code','buyorsell','original_value','target_value'])
                stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
            else:
                stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'buy',current_value_tmp,target_value_tmp]],columns=['stock_code','buyorsell','original_value','target_value'])
                stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
        #
        stock_to_trade_df.index = np.arange(0,stock_to_trade_df.shape[0],1)

        return stock_to_trade_df


    # 计算股票的DailyReturn
    def get_stock_daily_return(self,stock_code,freq,lag):
        hStocks = history(lag, freq, 'close', stock_code)
        #dailyReturns = hStocks.resample('D',how='last').pct_change().fillna(value=0, method=None, axis=0).values
        dailyReturns = hStocks.pct_change().fillna(value=0, method=None, axis=0).values
        return dailyReturns

    # 计算股票组合的DailyReturn
    def get_portfolio_daily_return(self,context,stock_alloc_ratio_df,freq,portfolio_risk_lag):
        # 初始化
        portfolio_dailyReturns = []
        for stock_code in stock_alloc_ratio_df.index:
            if stock_alloc_ratio_df['position_ratio'][stock_code]<>0:
                stock_dailyReturns = self.get_stock_daily_return(stock_code,freq,portfolio_risk_lag)
                tmp_list = []
                for i in range(len(stock_dailyReturns)):
                    tmp_list.append(stock_dailyReturns[i]*stock_alloc_ratio_df['position_ratio'][stock_code])
                # 组合的累加
                if portfolio_dailyReturns:
                    tmp_list_2 = []
                    for i in range(len(portfolio_dailyReturns)):
                        tmp_list_2.append(portfolio_dailyReturns[i]+tmp_list[i])
                    portfolio_dailyReturns = tmp_list_2
                else:
                    portfolio_dailyReturns = tmp_list
        return portfolio_dailyReturns

    # 计算股票组合的ES风险系数
    def cal_portfolio_risk_ES(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_dailyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'1d',portfolio_risk_lag)
        portfolio_dailyReturns_sort = sorted(portfolio_dailyReturns)

        # 根据置信水平，计算Alpha。表示基于正态分布函数下的事件发生概率
        if portfolio_confidence_level   == 1.96:
            alpha = (1 - 0.95)
        elif portfolio_confidence_level == 2.06:
            alpha = (1 - 0.96)
        elif portfolio_confidence_level == 2.18:
            alpha = (1 - 0.97)
        elif portfolio_confidence_level == 2.34:
            alpha = (1 - 0.98)
        elif portfolio_confidence_level == 2.58:
            alpha = (1 - 0.99)
        elif portfolio_confidence_level == 5:
            alpha = (1 - 0.99999)
        else:
            alpha = (1 - 0.95)
        # 根据risk_lag(采样期间)和alpha，计算ES的期间
        ES_sample = portfolio_risk_lag * alpha
        # 初始化
        count = 0
        sum_value = 0
        # 计算ES的和
        for i in range(len(portfolio_dailyReturns_sort)):
            if i < ES_sample:
                sum_value = sum_value+portfolio_dailyReturns_sort[i][0]
                count = count+1
        # 计算ES
        if count == 0:
            ES = 0
        else:
            ES = -(sum_value / ES_sample)
        if isnan(ES):
            ES = 0

        return ES

    # 计算股票组合的VaR风险系数
    def cal_portfolio_risk_VaR(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_dailyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'1d',portfolio_risk_lag)
        VaR_ratio = 1.0 * portfolio_confidence_level * np.std(portfolio_dailyReturns)
        return VaR_ratio

    # 根据股票组合的整体风险，计算整理仓位比例
    def cal_portfolio_alloc_ratio(self,context,stock_alloc_ratio_df):
        # 计算股票组合的ES风险
        portfolio_ES_ratio = self.cal_portfolio_risk_ES(context,stock_alloc_ratio_df,g.portfolio_risk_lag,g.portfolio_confidence_level)
        # 计算股票组合的VaR风险
        portfolio_VaR_ratio = self.cal_portfolio_risk_VaR(context,stock_alloc_ratio_df,g.portfolio_risk_lag,g.portfolio_confidence_level)

        # 计算风险金
        risk_money = context.portfolio.portfolio_value * g.portfolio_risk_rate
        maxrisk_money = 1.2 * risk_money
        # 计算可承受风险下，投资组合的金额
        portfolio_risk_value_ES = 0
        if portfolio_ES_ratio:
            portfolio_risk_value_ES = maxrisk_money / portfolio_ES_ratio

        portfolio_risk_value_VaR = 0
        if portfolio_VaR_ratio:
            portfolio_risk_value_VaR = risk_money / portfolio_VaR_ratio

        portfolio_risk_value = 0
        if portfolio_risk_value_ES == 0:
            portfolio_risk_value = portfolio_risk_value_VaR
        elif portfolio_risk_value_VaR == 0:
            portfolio_risk_value = portfolio_risk_value_ES
        else:
            portfolio_risk_value = min(portfolio_risk_value_ES,portfolio_risk_value_VaR)

            #log
            if portfolio_risk_value_ES<portfolio_risk_value_VaR:
                print 'ES:',portfolio_ES_ratio
            else:
                print 'VaR:',portfolio_VaR_ratio
        #
        total_value = context.portfolio.portfolio_value
        if portfolio_risk_value>total_value:
            portfolio_alloc_ratio = 1.0
        else:
            portfolio_alloc_ratio = round((portfolio_risk_value/total_value),2)


        return portfolio_alloc_ratio


    # Submain
    def get_stock_to_trade_df(self,context,stock_to_hold_list):
        # 按照风险计算各支股票的持仓比例
        stock_alloc_ratio_df = self.cal_stock_alloc_ratio(context,stock_to_hold_list)

        # 根据股票组合的整体风险，计算整理仓位比例
        portfolio_alloc_ratio = self.cal_portfolio_alloc_ratio(context,stock_alloc_ratio_df)

        print 'Portfolio Alloction Ratio',portfolio_alloc_ratio

        # 根据各支股票的持仓比例，计算调仓信息
        stock_to_trade_df = self.get_stock_trade_info(context,stock_alloc_ratio_df,portfolio_alloc_ratio)

        return stock_to_trade_df

################################################################################
class lh_operation_lib():

    def __init__(self, _period = '1d'):
        pass

    def stock_trade_operation(self,context,trade_flag,stock_to_trade_df):
        for i in stock_to_trade_df.index:
            if stock_to_trade_df['buyorsell'][i]==trade_flag:
                order_target_value(stock_to_trade_df['stock_code'][i], stock_to_trade_df['target_value'][i])

    # Submain
    def trade_execution(self,context,stock_to_trade_df):
        # 执行交易
        self.stock_trade_operation(context,'sell',stock_to_trade_df)
        self.stock_trade_operation(context,'buy',stock_to_trade_df)


'''
================================================================================
每天收盘后
================================================================================
'''
# 每天收盘后做的事情
# 进行长运算（本策略中不需要）
def after_trading_end(context):
    return
