# LH_VS_价值策略


# 是否开启性能分析
#enable_profile()

'''
================================================================================
导入Python库文件
================================================================================
'''
import pandas as pd
import numpy as np
import datetime as dt
from six import StringIO

'''
================================================================================
总体回测前
================================================================================
'''
#总体回测前要做的事情,g变量设定后无法在交易中通过更新代码的方式进行修改
def initialize(context):
    set_variables()                          # 设置中间变量
    set_backtest()                           # 设置回测条件
    set_benchmark('000300.XSHG')             # 设置回测基准
    #set_benchmark('399006.XSHE')
    set_trade_freq()                         # 设置交易频率，按天、周、月



#设置中间变量，仅定义需要在回测间保存的变量
def set_variables():
    # 计算待持有的股票列表
    g.intra_industry_count = 2               # 定义组合中同一个行业的股票个数
    g.stock_to_buy_limit = 10                # 定义买入股票的排名阈值
    #g.stock_to_sell_limit = 15               # 定义卖出股票的排名阈值
    # 计算持仓比例
    g.risk_lag = 180                         # 定义计算风险的分析期间
    g.confidence_level = 2.58                # 定义置信率，即：正态分布下的发生概率，1.96, 95%; 2.06, 96%; 2.18, 97%; 2.34, 98%; 2.58, 99%; 5, 99.9999%
    g.portfolio_risk_lag = 60
    g.portfolio_confidence_level = 1.96      # 1.96, 95%
    g.portfolio_risk_rate = 0.03             # 定义能够成熟的最大损失

    g.portfolio_risk_lag_w = 30
    g.portfolio_confidence_level_w = 2.18    # 1.96, 95%
    g.portfolio_risk_rate_w = 0.05           # 定义能够成熟的最大损失

#设置回测条件
def set_backtest():
    set_option('use_real_price',True)        # 用真实价格交易
    log.set_level('order','error')           # 设置报错等级


def set_trade_freq():
    # 指定每月第一个交易日, 在开盘第一分钟执行
    #run_monthly(monthly, 1, 'open')

    # 指定每周倒数第一个交易日, 在开盘前执行, 此函数中不能下单
    #run_weekly(weekly, -1, 'before_open')
    run_weekly(lh_main,-1,'open')

    # 指定每天收盘后执行, 此函数中不能下单
    #run_daily(daily, 'after_close')
    #run_daily(lh_main,'open')

    # 指定在每天的10:00运行, 必须选择分钟回测, 否则不会执行
    #run_daily(daily, '10:00')

    # 指定在每天的14:00运行, 必须选择分钟回测, 否则不会执行
    #run_daily(daily, '14:00')

'''
================================================================================
每天开盘前
================================================================================
'''
#每天开盘前要做的事情
def before_trading_start(context):

    # 设置手续费
    set_slip_fee(context)

    # 更新股票的历史季报信息(代码已移到最后)
    #update_stock_past_perf_info(context)

# 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0))
    # 根据不同的时间段设置手续费
    dt=context.current_dt
    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))


'''
================================================================================
交易时
================================================================================
'''
def lh_main(context):

    # 引用 lib
    g.prepare = lh_prepare_lib()
    g.algorithm = lh_algo_lib()
    g.trade = lh_trade_lib()
    g.operation = lh_operation_lib()


    # 取得股票池列表
    g.stock_pool_list = g.prepare.get_stock_pool_list(context)

    # 计算待持有的股票列表
    g.stock_to_hold_list = g.algorithm.get_hold_stock_list(context,g.stock_pool_list)

    # 计算持有股票的仓位
    g.stock_to_trade_df = g.trade.get_stock_to_trade_df(context,g.stock_to_hold_list)

    # 执行卖出和买入操作
    g.operation.trade_execution(context,g.stock_to_trade_df)



################################################################################
################################################################################
class lh_prepare_lib():

    def __init__(self, _period = '1d'):
        pass

    def set_stock_pool_scope(self,context):
        initial_stocks = list(get_all_securities(['stock'], context.current_dt.date()).index)
        return initial_stocks

    def delete_pause_st_stock(self,context,initial_stocks):
        # 判断初始股票池的股票是否停牌和ST，返回list
        paused_info = []
        st_info = []
        current_data = get_current_data()
        for i in initial_stocks:
            paused_info.append(current_data[i].paused)
            st_info.append(current_data[i].is_st)
        df_paused_info = pd.DataFrame({'paused_info':paused_info},index = initial_stocks)
        df_st_info = pd.DataFrame({'st_info':st_info},index = initial_stocks)

        unpaused_stocks =list(df_paused_info.index[df_paused_info.paused_info == False])
        unst_stocks = list(df_st_info.index[df_st_info.st_info == False])
        unsuspened_stocks = list(set(unpaused_stocks) & set(unst_stocks))
        return unsuspened_stocks

    def delete_new_stock(self,context,stock_list,deltaday):
        deltaDate = context.current_dt.date() - dt.timedelta(deltaday)
        stock_list_new = []
        for stock in stock_list:
            if get_security_info(stock).start_date < deltaDate:
                stock_list_new.append(stock)
        return stock_list_new

    def delete_cycle_industry(self,context,stock_pool_list):
        # 定义周期性行业
        cycle_industry = [#'A01', #	农业 	1993-09-17
                          #'A02', # 林业 	1996-12-06
                          #'A03', #	畜牧业 	1997-06-11
                          #'A04', #	渔业 	1993-05-07
                          #'A05', #	农、林、牧、渔服务业 	1997-05-30
                          'B06', # 煤炭开采和洗选业 	1994-01-06
                          'B07', # 石油和天然气开采业 	1996-06-28
                          'B08', # 黑色金属矿采选业 	1997-07-08
                          'B09', # 有色金属矿采选业 	1996-03-20
                          'B11', # 开采辅助活动 	2002-02-05
                          #'C13', #	农副食品加工业 	1993-12-15
                          #C14 	食品制造业 	1994-08-18
                          #C15 	酒、饮料和精制茶制造业 	1992-10-12
                          #C17 	纺织业 	1992-06-16
                          #C18 	纺织服装、服饰业 	1993-12-31
                          #C19 	皮革、毛皮、羽毛及其制品和制鞋业 	1994-04-04
                          #C20 	木材加工及木、竹、藤、棕、草制品业 	2005-05-10
                          #C21 	家具制造业 	1996-04-25
                          #C22 	造纸及纸制品业 	1993-03-12
                          #C23 	印刷和记录媒介复制业 	1994-02-24
                          #C24 	文教、工美、体育和娱乐用品制造业 	2007-01-10
                          'C25', # 石油加工、炼焦及核燃料加工业 	1993-10-25
                          'C26', # 化学原料及化学制品制造业 	1990-12-19
                          #C27 	医药制造业 	1993-06-29
                          'C28', # 化学纤维制造业 	1993-07-28
                          'C29', # 橡胶和塑料制品业 	1992-08-28
                          'C30', # 非金属矿物制品业 	1992-02-28
                          'C31', # 黑色金属冶炼及压延加工业 	1994-01-06
                          'C32', # 有色金属冶炼和压延加工业 	1996-02-15
                          'C33', # 金属制品业 	1993-11-30
                          'C34', # 通用设备制造业 	1992-03-27
                          'C35', # 专用设备制造业 	1992-07-01
                          'C36', # 汽车制造业 	1992-07-24
                          'C37', # 铁路、船舶、航空航天和其它运输设备制造业 	1992-03-31
                          'C38', # 电气机械及器材制造业 	1990-12-19
                          #C39 	计算机、通信和其他电子设备制造业 	1990-12-19
                          #C40 	仪器仪表制造业 	1993-09-17
                          'C41', # 其他制造业 	1992-08-14
                          #C42 	废弃资源综合利用业 	2012-10-26
                          'D44', # 电力、热力生产和供应业 	1993-04-16
                          #D45 	燃气生产和供应业 	2000-12-11
                          #D46 	水的生产和供应业 	1994-02-24
                          'E47', # 房屋建筑业 	1993-04-29
                          'E48', # 土木工程建筑业 	1994-01-28
                          'E50', # 建筑装饰和其他建筑业 	1997-05-22
                          #F51 	批发业 	1992-05-06
                          #F52 	零售业 	1992-09-02
                          'G53', # 铁路运输业 	1998-05-11
                          'G54', # 道路运输业 	1991-01-14
                          'G55', # 水上运输业 	1993-11-19
                          'G56', # 航空运输业 	1997-11-05
                          'G58', # 装卸搬运和运输代理业 	1993-05-05
                          #G59 	仓储业 	1996-06-14
                          #H61 	住宿业 	1993-11-18
                          #H62 	餐饮业 	1997-04-30
                          #I63 	电信、广播电视和卫星传输服务 	1992-12-02
                          #I64 	互联网和相关服务 	1992-05-07
                          #I65 	软件和信息技术服务业 	1992-08-20
                          'J66', # 货币金融服务 	1991-04-03
                          'J67', # 资本市场服务 	1994-01-10
                          'J68', # 保险业 	2007-01-09
                          'J69', # 其他金融业 	2012-10-26
                          'K70', # 房地产业 	1992-01-13
                          #L71 	租赁业 	1997-01-30
                          #L72 	商务服务业 	1996-08-29
                          #M73 	研究和试验发展 	2012-10-26
                          'M74', # 专业技术服务业 	2007-02-15
                          #N77 	生态保护和环境治理业 	2012-10-26
                          #N78 	公共设施管理业 	1992-08-07
                          #P82 	教育 	2012-10-26
                          #Q83 	卫生 	2007-02-05
                          #R85 	新闻和出版业 	1992-12-08
                          #R86 	广播、电视、电影和影视录音制作业 	1994-02-24
                          #R87 	文化艺术业 	2012-10-26
                          #S90 	综合 	1990-12-10
                          ]

        for industry in cycle_industry:
            cycle_industry_stocks = get_industry_stocks(industry)
            stock_pool_list = list(set(stock_pool_list).difference(set(cycle_industry_stocks)))

        return stock_pool_list

    # submain
    def get_stock_pool_list(self,context):
        # 初始化
        initial_stocks = self.set_stock_pool_scope(context)
        # 去除停牌和ST的股票
        stock_pool_list = self.delete_pause_st_stock(context,initial_stocks)
        # 去除刚上市的股票，因为新股无法根据历史走势计算风险系数
        stock_pool_list = self.delete_new_stock(context,stock_pool_list,600)
        # 去除周期性行业，暂时效果不好
        #stock_pool_list = self.delete_cycle_industry(context,stock_pool_list)

        return stock_pool_list

################################################################################
class lh_algo_lib():

    def __init__(self, _period = '1d'):
        pass

    def filter_by_basic_info(self,context,stock_pool_list):
        # 查询数据
        q_data = query(valuation.code, \
                       valuation.pe_ratio, \
                       valuation.pb_ratio, \
                       valuation.ps_ratio, \
                       valuation.pcf_ratio, \
                       indicator.roe, \
                       indicator.roa, \
                       indicator.inc_revenue_year_on_year, \
                       indicator.inc_operation_profit_year_on_year, \
                       indicator.inc_net_profit_year_on_year \
                         ).filter(valuation.code.in_(stock_pool_list))
        df_data = get_fundamentals(q_data,context.current_dt.date())
        df_data = df_data.dropna()

        # 重新给columns命名
        df_data.columns = ['code','pe','pb','ps','pcf','roe','roa','inc_rev_yoy','inc_opft_yoy','inc_npft_yoy']

        # 取基本面均为正的股票
        df_data = df_data[(df_data.pe > 0)&
                          (df_data.pb > 0)&
                          (df_data.ps > 0)&
                          #(df_data.pcf > -100)&
                          (df_data.roe > 0)&
                          (df_data.roa > 0)&
                          (df_data.inc_rev_yoy > 0)&
                          (df_data.inc_opft_yoy > 0)&
                          (df_data.inc_npft_yoy > 0)
                          ]

        # 取得筛选后的股票列表
        stock_pool_list = list(df_data['code'])

        return stock_pool_list

    def filter_by_past_perf(self,context,stock_pool_list):

        # 读取文件
        body = read_file('data/PROD/stock_past_perf_info.csv')
        # 读取数据的第一列为index
        pd_past_perf_info = pd.read_csv(StringIO(body), index_col=0)

        # 取得符合筛选后股票列表的DF
        df_past_perf = pd_past_perf_info.loc[stock_pool_list,:]

        # 以下为判断逻辑
        # 1. 三个同比增长指标是否均保持连续2个季度的增长（最近一个季度的增长在基本面条件中已限制）
        df_past_perf = df_past_perf[df_past_perf.last1_inc_rev_yoy > 0]
        df_past_perf = df_past_perf[df_past_perf.last1_inc_opft_yoy > 0]
        df_past_perf = df_past_perf[df_past_perf.last1_inc_npft_yoy > 0]
        # 2. 当期三个同比增长指标必须均在历史增长的均值之上
        df_past_perf = df_past_perf[df_past_perf.last0_inc_rev_yoy > df_past_perf.hmean_inc_rev_yoy]
        df_past_perf = df_past_perf[df_past_perf.last0_inc_opft_yoy > df_past_perf.hmean_inc_opft_yoy]
        df_past_perf = df_past_perf[df_past_perf.last0_inc_npft_yoy > df_past_perf.hmean_inc_npft_yoy]
        # 3. 当期三个同比增长指标必须在历史增长的可控范围内，历史均值+1.5倍方差（后续可优化）
        df_past_perf = df_past_perf[df_past_perf.last0_inc_rev_yoy < df_past_perf.hmean_inc_rev_yoy + 1.5*df_past_perf.hstd_inc_rev_yoy]
        df_past_perf = df_past_perf[df_past_perf.last0_inc_opft_yoy < df_past_perf.hmean_inc_opft_yoy + 1.5*df_past_perf.hstd_inc_opft_yoy]
        df_past_perf = df_past_perf[df_past_perf.last0_inc_npft_yoy < df_past_perf.hmean_inc_npft_yoy + 1.5*df_past_perf.hstd_inc_npft_yoy]

        selected_stock_pool_list = df_past_perf.index.values

        return selected_stock_pool_list

    def get_PEG_df(self,context,stock_pool_list):
        # 查询股票池里股票的市盈率，收益增长率
        q_PE_G = query(valuation.code, \
                       valuation.pe_ratio, \
                       indicator.inc_revenue_year_on_year, \
                       indicator.inc_net_profit_year_on_year,\
                       valuation.market_cap, \
                         ).filter(valuation.code.in_(stock_pool_list))
        # 默认date = context.current_dt的前一天,使用默认值，避免未来函数，不建议修改
        df_data = get_fundamentals(q_PE_G,context.current_dt.date())
        df_data = df_data.dropna()
        # 重新给columns命名
        df_data.columns = ['code','pe','inc_rev_yoy','inc_npft_yoy','mkt_cap']

        # 得到一个Series：存放股票的PEG值
        stock_PEG = df_data['pe'].values / df_data['inc_npft_yoy'].values
        stock_PER = df_data['pe'].values / df_data['inc_rev_yoy'].values
        # 将PEG插入到df
        df_data.insert(df_data.shape[1],'peg',stock_PEG)
        df_data.insert(df_data.shape[1],'per',stock_PER)
        # 将df的index更新为股票代码，并删掉原股票代码列
        df_data.index = df_data['code'].values
        df_data = df_data.drop('code',axis=1)

        return df_data

    def filter_PEG_df(self,context,df_PEG):

        # 筛选出符合条件的股票
        df_sort_PEG = df_PEG[(df_PEG.peg<0.5)&
                            #(df_PEG.per<1.0)&
                             (df_PEG.inc_rev_yoy<150)&
                             (df_PEG.inc_npft_yoy<150)&
                             (df_PEG.mkt_cap<1000)]

        # 将股票排序
        #df_sort_PEG = df_sort_PEG.sort(columns=['peg'], ascending=[1])
        df_sort_PEG = df_sort_PEG.sort(columns=['mkt_cap'], ascending=[1])

        return df_sort_PEG

    def diversify_by_industry(self,context,df_sort_PEG):
        # 初始化
        industry_list = []
        # 读取数据文件
        body = read_file('data/stock_industry_info.csv')
        # 读取数据的第一列为index
        pd_data = pd.read_csv(StringIO(body), index_col=0)
        # 复制index
        peg_index = df_sort_PEG.index
        # 开始循环处理
        for stock_code in peg_index:
            # 防止行业信息不全
            if stock_code in pd_data.index:
                # 获得该股票的行业代码
                industry_code = pd_data['industry_code'][stock_code]
                # 进行判断
                if industry_list.count(industry_code) <= g.intra_industry_count:
                    # 将该行业code加入到列表
                    industry_list.append(industry_code)
                if industry_list.count(industry_code) > g.intra_industry_count:
                    # 删除该行
                    df_sort_PEG = df_sort_PEG.drop(stock_code)
        #df_sort_PEG.insert(5,'rank',np.arange(0,df_sort_PEG.shape[0]))
        return df_sort_PEG

    def get_stock_list_by_count(self,context,df_PEG_filter):
        if df_PEG_filter.shape[0] > g.stock_to_buy_limit
            stock_to_hold_list = df_PEG_filter.index.values[:g.stock_to_buy_limit]
        else:
            stock_to_hold_list = df_PEG_filter.index.values

        return stock_to_hold_list

    # submain
    def get_hold_stock_list(self,context,stock_pool_list):
        # 根据基本面数据对股票池代码的进行初步筛选
        stock_pool_list = self.filter_by_basic_info(context,stock_pool_list)

        # 计算股票的历史增长，去除增长率不稳定的股票
        #stock_pool_list = self.filter_by_past_perf(context,stock_pool_list)

        # 取得PEG df：index为股票代码，data为相应的PEG值
        df_stock = self.get_PEG_df(context, stock_pool_list)
        # 对PEG df进行筛选
        df_stock_filter = self.filter_PEG_df(context,df_stock)

        # 限制股票列表中每个行业所占股票的数量
        df_stock_filter = self.diversify_by_industry(context,df_stock_filter)

        # 取得待持有的股票列表
        stock_to_hold_list = self.get_stock_list_by_count(context,df_stock_filter)

        return stock_to_hold_list

################################################################################
class lh_trade_lib():

    def __init__(self, _period = '1d'):
        pass

    def get_stock_pause_info(self,context,stock_code):
        # 取得所有数据信息
        current_data = get_current_data()
        stock_pause_status = current_data[stock_code].paused

        return stock_pause_status

    def get_stock_zhangting_info(self,context,stock_code):
        # 取得所有数据信息
        current_data = get_current_data()
        # 判断涨停信息
        today_open = current_data[stock_code].day_open
        yest_close = history(count=1, unit='1d', field='close', security_list=stock_code).values
        zhangting_status = (today_open/yest_close > 1.09)
        return zhangting_status

    # ES风险计算逻辑
    def cal_stock_risk_ES(self,context,stock_code,risk_lag,confidence_level):
        # 取得历史收盘数据
        #hStocks = history(risk_lag, '1d', 'close', stock_code)
        # 去除停牌期间的数据，避免ES计算的失真
        hStocks = history(risk_lag, '1d', 'close', stock_code, skip_paused=True)
        # 计算日收益率／日变动率
        #dailyReturns = hStocks.resample('D',how='last').pct_change().fillna(value=0, method=None, axis=0).values
        dailyReturns = hStocks.pct_change().fillna(value=0, method=None, axis=0).values
        # 按照升序排序
        dailyReturns_sort =  sorted(dailyReturns)

        # 根据置信水平，计算Alpha。表示基于正态分布函数下的事件发生概率
        if confidence_level   == 1.96:
            alpha = (1 - 0.95)
        elif confidence_level == 2.06:
            alpha = (1 - 0.96)
        elif confidence_level == 2.18:
            alpha = (1 - 0.97)
        elif confidence_level == 2.34:
            alpha = (1 - 0.98)
        elif confidence_level == 2.58:
            alpha = (1 - 0.99)
        elif confidence_level == 5:
            alpha = (1 - 0.99999)
        else:
            alpha = (1 - 0.95)
        # 根据risk_lag(采样期间)和alpha，计算ES的期间
        ES_sample = risk_lag * alpha
        # 初始化
        count = 0
        sum_value = 0
        # 计算ES的和
        for i in range(len(dailyReturns_sort)):
            if i < ES_sample:
                sum_value = sum_value+dailyReturns_sort[i][0]
                count = count+1
        # 计算ES
        if count == 0:
            ES = 0
        else:
            # 增加ceil函数，修正当ES_sample为1.X时，对ES的放大作用
            ES = -(sum_value / ceil(ES_sample))
        if isnan(ES):
            ES = 0
        return ES

    # 新的配仓分配逻辑
    def cal_stock_alloc_ratio(self,context,stock_to_hold_list):
        # 初始化
        stock_alloc_ratio_df = pd.DataFrame(index=stock_to_hold_list,columns=['risk_ES','position','position_ratio'])
        # 计算风险系数ES的值
        for stock_code_tmp in stock_to_hold_list:
            stock_alloc_ratio_df['risk_ES'][stock_code_tmp] = self.cal_stock_risk_ES(context,stock_code_tmp,g.risk_lag,g.confidence_level)
            stock_alloc_ratio_df['position'][stock_code_tmp] = 1.0 / stock_alloc_ratio_df['risk_ES'][stock_code_tmp]
        # 根据ES值计算持仓比例
        total_position = sum(stock_alloc_ratio_df['position'].values)
        for stock_code_tmp in stock_to_hold_list:
            ratio_tmp = stock_alloc_ratio_df['position'][stock_code_tmp]/total_position
            if isnan(ratio_tmp):
                ratio_tmp = 0
            stock_alloc_ratio_df['position_ratio'][stock_code_tmp] = round(ratio_tmp, 4)

        return stock_alloc_ratio_df

    # 根据各支股票的持仓比例，计算调仓信息
    def get_stock_trade_info(self,context,stock_alloc_ratio_df,portfolio_alloc_ratio):
        # 初始化
        stock_to_trade_df = pd.DataFrame(columns=['stock_code','buyorsell','original_value','target_value'])
        # 取得当前的持仓信息
        curr_hold_stock_list = context.portfolio.positions.keys()
        # 取得可分配的总金额
        total_capital = context.portfolio.portfolio_value * portfolio_alloc_ratio
        # 取得待卖出的股票中，已停牌和已涨停的股票信息
        unavailable_capital = 0
        # 如果该股票在当前持仓中，但不在未来持仓清单中
        for stock_code in curr_hold_stock_list:
            if stock_code not in stock_alloc_ratio_df.index:
                if self.get_stock_pause_info(context,stock_code)==True:
                    unavailable_capital = unavailable_capital+context.portfolio.positions[stock_code].value
                elif self.get_stock_zhangting_info(context,stock_code)==True:
                    unavailable_capital = unavailable_capital+context.portfolio.positions[stock_code].value
                else:
                    current_value_tmp = context.portfolio.positions[stock_code].value
                    stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'sell',current_value_tmp,0.0]],columns=['stock_code','buyorsell','original_value','target_value'])
                    stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
        # 计算可分配的金额
        available_capital = total_capital-unavailable_capital
        # Loop
        for stock_code in stock_alloc_ratio_df.index:
            current_value_tmp = context.portfolio.positions[stock_code].value
            target_value_tmp = stock_alloc_ratio_df['position_ratio'][stock_code] * available_capital
            if current_value_tmp > target_value_tmp:
                stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'sell',current_value_tmp,target_value_tmp]],columns=['stock_code','buyorsell','original_value','target_value'])
                stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
            else:
                stock_to_trade_df_tmp = pd.DataFrame([[stock_code,'buy',current_value_tmp,target_value_tmp]],columns=['stock_code','buyorsell','original_value','target_value'])
                stock_to_trade_df = pd.concat([stock_to_trade_df,stock_to_trade_df_tmp])
        #
        stock_to_trade_df.index = np.arange(0,stock_to_trade_df.shape[0],1)

        return stock_to_trade_df


    # 计算股票的DailyReturn
    def get_stock_daily_return(self,stock_code,freq,lag):
        hStocks = history(lag, freq, 'close', stock_code)
        #dailyReturns = hStocks.resample('D',how='last').pct_change().fillna(value=0, method=None, axis=0).values
        dailyReturns = hStocks.pct_change().fillna(value=0, method=None, axis=0).values
        return dailyReturns

    # 计算股票组合的DailyReturn
    def get_portfolio_daily_return(self,context,stock_alloc_ratio_df,freq,portfolio_risk_lag):
        # 初始化
        portfolio_dailyReturns = []
        for stock_code in stock_alloc_ratio_df.index:
            if stock_alloc_ratio_df['position_ratio'][stock_code]<>0:
                stock_dailyReturns = self.get_stock_daily_return(stock_code,freq,portfolio_risk_lag)
                tmp_list = []
                for i in range(len(stock_dailyReturns)):
                    tmp_list.append(stock_dailyReturns[i]*stock_alloc_ratio_df['position_ratio'][stock_code])
                # 组合的累加
                if portfolio_dailyReturns:
                    tmp_list_2 = []
                    for i in range(len(portfolio_dailyReturns)):
                        tmp_list_2.append(portfolio_dailyReturns[i]+tmp_list[i])
                    portfolio_dailyReturns = tmp_list_2
                else:
                    portfolio_dailyReturns = tmp_list
        return portfolio_dailyReturns

    # 计算股票组合的ES风险系数
    def cal_portfolio_risk_ES(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_dailyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'1d',portfolio_risk_lag)
        portfolio_dailyReturns_sort = sorted(portfolio_dailyReturns)

        # 根据置信水平，计算Alpha。表示基于正态分布函数下的事件发生概率
        if portfolio_confidence_level   == 1.96:
            alpha = (1 - 0.95)
        elif portfolio_confidence_level == 2.06:
            alpha = (1 - 0.96)
        elif portfolio_confidence_level == 2.18:
            alpha = (1 - 0.97)
        elif portfolio_confidence_level == 2.34:
            alpha = (1 - 0.98)
        elif portfolio_confidence_level == 2.58:
            alpha = (1 - 0.99)
        elif portfolio_confidence_level == 5:
            alpha = (1 - 0.99999)
        else:
            alpha = (1 - 0.95)
        # 根据risk_lag(采样期间)和alpha，计算ES的期间
        ES_sample = portfolio_risk_lag * alpha
        # 初始化
        count = 0
        sum_value = 0
        # 计算ES的和
        for i in range(len(portfolio_dailyReturns_sort)):
            if i < ES_sample:
                sum_value = sum_value+portfolio_dailyReturns_sort[i][0]
                count = count+1
        # 计算ES
        if count == 0:
            ES = 0
        else:
            # 增加ceil函数，修正当ES_sample为1.X时，对ES的放大作用
            ES = -(sum_value / ceil(ES_sample))
        if isnan(ES):
            ES = 0

        return ES

    def cal_portfolio_risk_ES_w(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_weeklyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'5d',portfolio_risk_lag)
        portfolio_weeklyReturns_sort = sorted(portfolio_weeklyReturns)

        # 根据置信水平，计算Alpha。表示基于正态分布函数下的事件发生概率
        if portfolio_confidence_level   == 1.96:
            alpha = (1 - 0.95)
        elif portfolio_confidence_level == 2.06:
            alpha = (1 - 0.96)
        elif portfolio_confidence_level == 2.18:
            alpha = (1 - 0.97)
        elif portfolio_confidence_level == 2.34:
            alpha = (1 - 0.98)
        elif portfolio_confidence_level == 2.58:
            alpha = (1 - 0.99)
        elif portfolio_confidence_level == 5:
            alpha = (1 - 0.99999)
        else:
            alpha = (1 - 0.95)
        # 根据risk_lag(采样期间)和alpha，计算ES的期间
        ES_sample = portfolio_risk_lag * alpha
        # 初始化
        count = 0
        sum_value = 0
        # 计算ES的和
        for i in range(len(portfolio_weeklyReturns_sort)):
            if i < ES_sample:
                sum_value = sum_value+portfolio_weeklyReturns_sort[i][0]
                count = count+1
        # 计算ES
        if count == 0:
            ES_w = 0
        else:
            # 增加ceil函数，修正当ES_sample为1.X时，对ES的放大作用
            ES_w = -(sum_value / ceil(ES_sample))
        if isnan(ES_w):
            ES_w = 0

        return ES_w

    # 计算股票组合的VaR风险系数
    def cal_portfolio_risk_VaR(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_dailyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'1d',portfolio_risk_lag)
        VaR_ratio = 1.0 * portfolio_confidence_level * np.std(portfolio_dailyReturns)
        return VaR_ratio

    def cal_portfolio_risk_VaR_w(self,context,stock_alloc_ratio_df,portfolio_risk_lag,portfolio_confidence_level):
        # 计算投资组合的Daily return
        portfolio_weeklyReturns = self.get_portfolio_daily_return(context,stock_alloc_ratio_df,'5d',portfolio_risk_lag)
        VaR_ratio_w = 1.0 * portfolio_confidence_level * np.std(portfolio_weeklyReturns)
        return VaR_ratio_w

    # 根据股票组合的整体风险，计算整理仓位比例
    def cal_portfolio_alloc_ratio_d(self,context,stock_alloc_ratio_df):
        # 计算股票组合的ES风险
        portfolio_ES_ratio = self.cal_portfolio_risk_ES(context,stock_alloc_ratio_df,g.portfolio_risk_lag,g.portfolio_confidence_level)
        # 计算股票组合的VaR风险
        portfolio_VaR_ratio = self.cal_portfolio_risk_VaR(context,stock_alloc_ratio_df,g.portfolio_risk_lag,g.portfolio_confidence_level)

        # 计算风险金
        risk_money = context.portfolio.portfolio_value * g.portfolio_risk_rate
        maxrisk_money = 1.2 * risk_money
        # 计算可承受风险下，投资组合的金额
        portfolio_risk_value_ES = 0
        if portfolio_ES_ratio:
            portfolio_risk_value_ES = maxrisk_money / portfolio_ES_ratio

        portfolio_risk_value_VaR = 0
        if portfolio_VaR_ratio:
            portfolio_risk_value_VaR = risk_money / portfolio_VaR_ratio

        portfolio_risk_value = 0
        if portfolio_risk_value_ES == 0:
            portfolio_risk_value = portfolio_risk_value_VaR
        elif portfolio_risk_value_VaR == 0:
            portfolio_risk_value = portfolio_risk_value_ES
        else:
            portfolio_risk_value = min(portfolio_risk_value_ES,portfolio_risk_value_VaR)

            #log
            if portfolio_risk_value_ES<portfolio_risk_value_VaR:
                print 'ES:',portfolio_ES_ratio
            else:
                print 'VaR:',portfolio_VaR_ratio
        #
        total_value = context.portfolio.portfolio_value
        if portfolio_risk_value>total_value:
            portfolio_alloc_ratio = 1.0
        else:
            portfolio_alloc_ratio = round((portfolio_risk_value/total_value),2)


        return portfolio_alloc_ratio

    def cal_portfolio_alloc_ratio_w(self,context,stock_alloc_ratio_df):
        # 计算股票组合的ES风险
        portfolio_ES_ratio = self.cal_portfolio_risk_ES_w(context,stock_alloc_ratio_df,g.portfolio_risk_lag_w,g.portfolio_confidence_level_w)
        # 计算股票组合的VaR风险
        portfolio_VaR_ratio = self.cal_portfolio_risk_VaR_w(context,stock_alloc_ratio_df,g.portfolio_risk_lag_w,g.portfolio_confidence_level_w)

        # 计算风险金
        risk_money = context.portfolio.portfolio_value * g.portfolio_risk_rate_w
        maxrisk_money = 1.2 * risk_money
        # 计算可承受风险下，投资组合的金额
        portfolio_risk_value_ES = 0
        if portfolio_ES_ratio:
            portfolio_risk_value_ES = maxrisk_money / portfolio_ES_ratio

        portfolio_risk_value_VaR = 0
        if portfolio_VaR_ratio:
            portfolio_risk_value_VaR = risk_money / portfolio_VaR_ratio

        portfolio_risk_value = 0
        if portfolio_risk_value_ES == 0:
            portfolio_risk_value = portfolio_risk_value_VaR
        elif portfolio_risk_value_VaR == 0:
            portfolio_risk_value = portfolio_risk_value_ES
        else:
            portfolio_risk_value = min(portfolio_risk_value_ES,portfolio_risk_value_VaR)

            #log
            if portfolio_risk_value_ES<portfolio_risk_value_VaR:
                print 'ES_w:',portfolio_ES_ratio
            else:
                print 'VaR_w:',portfolio_VaR_ratio
        #
        total_value = context.portfolio.portfolio_value
        if portfolio_risk_value>total_value:
            portfolio_alloc_ratio_w = 1.0
        else:
            portfolio_alloc_ratio_w = round((portfolio_risk_value/total_value),2)


        return portfolio_alloc_ratio_w

    # Submain
    def get_stock_to_trade_df(self,context,stock_to_hold_list):
        # 按照风险计算各支股票的持仓比例
        stock_alloc_ratio_df = self.cal_stock_alloc_ratio(context,stock_to_hold_list)

        # 根据股票组合的整体风险，计算整理仓位比例
        portfolio_alloc_ratio = self.cal_portfolio_alloc_ratio_d(context,stock_alloc_ratio_df)

        #portfolio_alloc_ratio_w = self.cal_portfolio_alloc_ratio_w(context,stock_alloc_ratio_df)

        #portfolio_alloc_ratio = min(portfolio_alloc_ratio, portfolio_alloc_ratio_w)

        print 'Portfolio Alloction Ratio',portfolio_alloc_ratio

        # 根据各支股票的持仓比例，计算调仓信息
        stock_to_trade_df = self.get_stock_trade_info(context,stock_alloc_ratio_df,portfolio_alloc_ratio)

        print stock_to_trade_df

        return stock_to_trade_df

################################################################################
class lh_operation_lib():

    def __init__(self, _period = '1d'):
        pass

    def stock_trade_operation(self,context,trade_flag,stock_to_trade_df):
        for i in stock_to_trade_df.index:
            if stock_to_trade_df['buyorsell'][i]==trade_flag:
                order_target_value(stock_to_trade_df['stock_code'][i], stock_to_trade_df['target_value'][i])

    # Submain
    def trade_execution(self,context,stock_to_trade_df):
        # 执行交易
        self.stock_trade_operation(context,'sell',stock_to_trade_df)
        self.stock_trade_operation(context,'buy',stock_to_trade_df)


'''
================================================================================
每天收盘后
================================================================================
'''
# 每天收盘后做的事情
# 进行长运算（本策略中不需要）
def after_trading_end(context):

    # 暂不使用的代码备份
    def update_stock_past_perf_info(context):

        def __get_quarter_list(stock_code):

            # 根据当前日期，计算可以获取的最新的季报发布日期
            statDate_query = query(indicator.code, indicator.statDate).filter(indicator.code.in_([stock_code]))
            last_statDate = get_fundamentals(statDate_query)['statDate'][0]
            # 取最近季报的年和月
            last_year = int(str(last_statDate)[0:4])
            last_month = str(last_statDate)[5:7]
            # 计算历史季报记录
            if last_month == '12':
                last_quarter = str(last_year) + 'q4'
                last_2quarter = str(last_year) + 'q3'
                last_3quarter = str(last_year) + 'q2'
                last_4quarter = str(last_year) + 'q1'
                last_5quarter = str(last_year - 1) + 'q4'

            elif last_month == '09':
                last_quarter = str(last_year) + 'q3'
                last_2quarter = str(last_year) + 'q2'
                last_3quarter = str(last_year) + 'q1'
                last_4quarter = str(last_year - 1) + 'q4'
                last_5quarter = str(last_year - 1) + 'q3'

            elif last_month == '06':
                last_quarter = str(last_year) + 'q2'
                last_2quarter = str(last_year) + 'q1'
                last_3quarter = str(last_year - 1) + 'q4'
                last_4quarter = str(last_year - 1) + 'q3'
                last_5quarter = str(last_year - 1) + 'q2'

            else:  #last_month == '03':
                last_quarter = str(last_year) + 'q1'
                last_2quarter = str(last_year - 1) + 'q4'
                last_3quarter = str(last_year - 1) + 'q3'
                last_4quarter = str(last_year - 1) + 'q2'
                last_5quarter = str(last_year - 1) + 'q1'

            quarter_list = [last_quarter,last_2quarter,last_3quarter,last_4quarter,last_5quarter]

            return quarter_list

        def __get_hquarter_info(stock_code,quarter_list):

            df_quarter_info = pd.DataFrame(columns=['code','statDate','inc_rev_yoy','inc_opft_yoy','inc_npft_yoy'])

            for quarter_tmp in quarter_list:
                q_indicator = query(indicator.code, \
                                    indicator.statDate, \
                                    indicator.inc_revenue_year_on_year, \
                                    indicator.inc_operation_profit_year_on_year, \
                                    indicator.inc_net_profit_year_on_year \
                                    ).filter(indicator.code.in_([stock_code]))
                df_data_indicator = get_fundamentals(q_indicator, statDate=quarter_tmp)
                df_data_indicator.columns = ['code','statDate','inc_rev_yoy','inc_opft_yoy','inc_npft_yoy']
                df_quarter_info = pd.concat([df_quarter_info, df_data_indicator])

            df_quarter_info.index = np.arange(0,df_quarter_info.shape[0],1)

            return df_quarter_info

        def __add_past_perf_info(pd_past_perf_info,stock_code):

            quarter_list = __get_quarter_list(stock_code)
            df_quarter_info = __get_hquarter_info(stock_code,quarter_list)

            # 计算值
            value_latest_statDate = df_quarter_info['statDate'][0]
            value_last0_inc_rev_yoy = df_quarter_info['inc_rev_yoy'][0]
            value_last1_inc_rev_yoy = df_quarter_info['inc_rev_yoy'][1]
            value_hmean_inc_rev_yoy = df_quarter_info['inc_rev_yoy'][1:].mean()
            value_hstd_inc_rev_yoy = df_quarter_info['inc_rev_yoy'][1:].std()
            value_last0_inc_opft_yoy = df_quarter_info['inc_opft_yoy'][0]
            value_last1_inc_opft_yoy = df_quarter_info['inc_opft_yoy'][1]
            value_hmean_inc_opft_yoy = df_quarter_info['inc_opft_yoy'][1:].mean()
            value_hstd_inc_opft_yoy = df_quarter_info['inc_opft_yoy'][1:].std()
            value_last0_inc_npft_yoy = df_quarter_info['inc_npft_yoy'][0]
            value_last1_inc_npft_yoy = df_quarter_info['inc_npft_yoy'][1]
            value_hmean_inc_npft_yoy = df_quarter_info['inc_npft_yoy'][1:].mean()
            value_hstd_inc_npft_yoy = df_quarter_info['inc_npft_yoy'][1:].std()

            pd_past_performance_tmp = pd.DataFrame([[value_latest_statDate,
                                                     value_last0_inc_rev_yoy,value_last1_inc_rev_yoy,value_hmean_inc_rev_yoy,value_hstd_inc_rev_yoy,
                                                     value_last0_inc_opft_yoy,value_last1_inc_opft_yoy,value_hmean_inc_opft_yoy,value_hstd_inc_opft_yoy,
                                                     value_last0_inc_npft_yoy,value_last1_inc_npft_yoy,value_hmean_inc_npft_yoy,value_hstd_inc_npft_yoy]],
                                                   columns=['latest_statDate',
                                                            'last0_inc_rev_yoy','last1_inc_rev_yoy','hmean_inc_rev_yoy','hstd_inc_rev_yoy',
                                                            'last0_inc_opft_yoy','last1_inc_opft_yoy','hmean_inc_opft_yoy','hstd_inc_opft_yoy',
                                                            'last0_inc_npft_yoy','last1_inc_npft_yoy','hmean_inc_npft_yoy','hstd_inc_npft_yoy'],
                                                   index=[stock_code])

            pd_past_perf_info = pd.concat([pd_past_perf_info,pd_past_performance_tmp])

            return pd_past_perf_info

        def __update_past_perf_info(pd_past_perf_info,stock_code):

            quarter_list = __get_quarter_list(stock_code)
            df_quarter_info = __get_hquarter_info(stock_code,quarter_list)

            pd_past_perf_info.is_copy = False
            # 计算值
            pd_past_perf_info.loc[stock_code,'latest_statDate'] = df_quarter_info['statDate'][0]
            pd_past_perf_info.loc[stock_code,'last0_inc_rev_yoy'] = df_quarter_info['inc_rev_yoy'][0]
            pd_past_perf_info.loc[stock_code,'last1_inc_rev_yoy'] = df_quarter_info['inc_rev_yoy'][1]
            pd_past_perf_info.loc[stock_code,'hmean_inc_rev_yoy'] = df_quarter_info['inc_rev_yoy'][1:].mean()
            pd_past_perf_info.loc[stock_code,'hstd_inc_rev_yoy'] = df_quarter_info['inc_rev_yoy'][1:].std()
            pd_past_perf_info.loc[stock_code,'last0_inc_opft_yoy'] = df_quarter_info['inc_opft_yoy'][0]
            pd_past_perf_info.loc[stock_code,'last1_inc_opft_yoy'] = df_quarter_info['inc_opft_yoy'][1]
            pd_past_perf_info.loc[stock_code,'hmean_inc_opft_yoy'] = df_quarter_info['inc_opft_yoy'][1:].mean()
            pd_past_perf_info.loc[stock_code,'hstd_inc_opft_yoy'] = df_quarter_info['inc_opft_yoy'][1:].std()
            pd_past_perf_info.loc[stock_code,'last0_inc_npft_yoy'] = df_quarter_info['inc_npft_yoy'][0]
            pd_past_perf_info.loc[stock_code,'last1_inc_npft_yoy'] = df_quarter_info['inc_npft_yoy'][1]
            pd_past_perf_info.loc[stock_code,'hmean_inc_npft_yoy'] = df_quarter_info['inc_npft_yoy'][1:].mean()
            pd_past_perf_info.loc[stock_code,'hstd_inc_npft_yoy'] = df_quarter_info['inc_npft_yoy'][1:].std()

            return pd_past_perf_info


        # 声明库文件
        g.pre_update = lh_prepare_lib()

        # 读取文件
        body = read_file('data/PROD/stock_past_perf_info.csv')
        # 读取数据的第一列为index
        pd_past_perf_info = pd.read_csv(StringIO(body), index_col=0)

        initial_stocks = g.pre_update.set_stock_pool_scope(context)
        initial_stocks = g.pre_update.delete_pause_st_stock(context,initial_stocks)
        initial_stocks = g.pre_update.delete_new_stock(context,initial_stocks,600)

        # 将新股增加的DF中
        new_stock_list = list(set(initial_stocks)-set(pd_past_perf_info.index.values))
        for stock_code in new_stock_list:
            pd_past_perf_info = __add_past_perf_info(pd_past_perf_info,stock_code)

        # 获取股票最新的季报发布日期
        statDate_query = query(indicator.code, indicator.statDate).filter(indicator.code.in_(initial_stocks))
        df_last_statDate = get_fundamentals(statDate_query)
        df_last_statDate.index = df_last_statDate['code'].values
        df_last_statDate = df_last_statDate.drop('code',axis=1)

        common_stock_list = list(set(initial_stocks) & set(pd_past_perf_info.index.values))
        df_last_statDate_common = df_last_statDate.loc[common_stock_list,:]
        pd_past_perf_info_common = pd_past_perf_info.loc[common_stock_list,:]
        df_update_past_perf = df_last_statDate_common[df_last_statDate_common.statDate <> pd_past_perf_info_common.latest_statDate]
        for stock_code in df_update_past_perf.index.values:
            pd_past_perf_info = __update_past_perf_info(pd_past_perf_info,stock_code)

        # 将DataFrame输出到文件
        write_file('data/PROD/stock_past_perf_info.csv', pd_past_perf_info.to_csv(index=True), append=False)

        print 'New Added Past Perf:', len(new_stock_list)
        print 'Updated Past Perf:', df_update_past_perf.shape[0]

    return
